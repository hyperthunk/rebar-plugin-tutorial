
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Introducing Rebar Plugins - Rebar Plugins</title>
  <meta name="author" content="Tim Watson">

  
  <meta name="description" content="This is the first post in a series on customising rebar using plugins.
Initially, I want to focus on how plugins work, then move on to see what kind &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hyperthunk.github.com/rebar-plugin-tutorial/blog/2011/12/29/introducing-rebar-plugins">
  <link href="/rebar-plugin-tutorial/favicon.png" rel="icon">
  <link href="/rebar-plugin-tutorial/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/rebar-plugin-tutorial/javascripts/modernizr-2.0.js"></script>
  <script src="/rebar-plugin-tutorial/javascripts/ender.js"></script>
  <script src="/rebar-plugin-tutorial/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/rebar-plugin-tutorial/atom.xml" rel="alternate" title="Rebar Plugins" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/rebar-plugin-tutorial/">Rebar Plugins</a></h1>
  
    <h2>Extreme Build Customisations</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/rebar-plugin-tutorial/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hyperthunk.github.com/rebar-plugin-tutorial" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/rebar-plugin-tutorial/">Blog</a></li>
  <li><a href="/rebar-plugin-tutorial/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Introducing Rebar Plugins</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-29T21:49:00+00:00" pubdate data-updated="true">Dec 29<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>This is the first post in a series on customising rebar using plugins.
Initially, I want to focus on how plugins work, then move on to see what kind
of extensibility they can provide to developers.</p>

<h3>Caveats</h3>

<p>Currently there&#8217;s no official API for plugins, so it&#8217;s best to limit which
internals or internal functions you rely on (even if they&#8217;re exported). What
this means empirically is that you&#8217;ll need to check your plugins for
compatibility whenever you upgrade to a new version of rebar. I recommend using
something like <a href="http://travis-ci.org">travis-ci</a> to keep on top of this.</p>

<h3>First things first</h3>

<p>Currently rebar supports two kinds of extensibility mechanism: Plugin
Extensions and Hooks. Hooks are a lightly documented feature, with the only
real explanation being the <a href="https://github.com/basho/rebar/blob/master/rebar.config.sample#L142">sample rebar config file</a>.
We’re not going to cover hooks in much detail, as they are simple enough to
understand and are only really applicable to simple scripting tasks that don’t
require, for example, cross platform support or complex logic. Plugin
Extensions on the other hand, are documented (to some extend anyway), and
provide a much greater degree of extensibility to developers.</p>

<p>Before we can talk sensibly about plugins, we need to take a look at some of
the fundamentals behind rebar, especially its handling of build configuration
files and command processing logic. For any given command, say <code>foo</code>, rebar
understands the command if (and only if) <em>one of the modules it knows about</em>
exports a function with a signature that matches:</p>

<ul>
<li>the name of the command and arity 2</li>
<li>the name of the command prefixed with pre_, and arity 2</li>
<li>the name of the command prefixed with post_, and arity 2</li>
</ul>


<p>We’ll be covering how rebar <em>knows about</em> modules later on, but for now we’ll
just assume it’s magic. For the command <code>foo</code> to have any meaning then, we’d
need at least one module with at least one of the following signatures
exported:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">foo</span><span class="p">).</span>
</span><span class='line'><span class="p">-</span><span class="ni">compile</span><span class="p">(</span><span class="n">export_all</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">pre_foo</span><span class="p">(_,</span> <span class="p">_)</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="nn">io</span><span class="p">:</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;we&#39;re running just before foo!</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">foo</span><span class="p">(_,</span> <span class="p">_)</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="nn">io</span><span class="p">:</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;we&#39;re in foo!</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">post_foo</span><span class="p">(_,</span> <span class="p">_)</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="nn">io</span><span class="p">:</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;we&#39;re running just after foo!</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">).</span>
</span></code></pre></td></tr></table></div></figure>


<p>Another essential is the four ways in which rebar handles build configuration.
When rebar first runs, before handling the current directory, it loads the
global config file from $HOME/.rebar/config if it actually exists, otherwise
creating an empty config set. The config for <em>any</em> subsequent directory is
handled by either (a) examining the terms in the local file <code>rebar.config</code> if
it exists, or (b) creating an empty config set.
When executing in the first, top level directory (referred to in the code as
the <code>base_dir</code>), rebar will check for a special global variable (passed as
<code>config=</code> or <code>-C &lt;config-name&gt;</code> on the command line)  which overrides
the name of the config file it should search in. This technique is only applied
to configuration files in the <code>base_dir</code>.</p>

<p>The fourth approach to configuration handling is not just for initialising new
configurations. As rebar executes user commands (e.g., <code>clean</code>, <code>compile</code>,
<code>eunit</code>, etc) in a given directory, it uses two special commands to obtain a
list of directories that need to be processed before the current one, and
providing the current directory is processed without error, afterwards as well.
These commands, <code>preprocess</code> and <code>postprocess</code>, can be exported by any module.
As rebar executes, it builds up a list of modules that understand the current
command. For each of these modules it tries to call <code>pre</code> and <code>postprocess</code>,
then traverses any pre- dirs before handling the current command in the current
directory. Once all the pre-processing is done, each module that exports one of
the three function signatures compatible with the current command is called
(for one or more of the <code>pre_&lt;command&gt;/2</code>, <code>&lt;command&gt;/2</code> and
<code>post_&lt;command&gt;/2</code> exports) to handle the actual command. The directories
returned by any postprocess calls are handled last of all.</p>

<p>What is vital to understand about all of this, is that as rebar traverses the
file system, recursively handling any pre- directories, in each new dir it
executes with a brand new rebar config set. This config set inherits the parent
configuration (i.e., the config set for the parent dir) but can override
certain configuration variables by providing it’s own rebar.config file. This
is how dependencies and applications stored in sub-directories are handled. The
salient points about this mechanism are that</p>

<ul>
<li>the only configuration file rebar notices in sub-directories is the one named rebar.config</li>
<li>any configuration override (passed with -C for example) is ignored in sub-directories</li>
<li>just because a local rebar.config overrides a variable/setting, this might not be applied</li>
</ul>


<p>Point #3 is a bit scary if you’re new to rebar, but essentially it is the
result of rebar’s config handling module exporting multiple config handling
functions, some of which get the local (i.e., the most locally scoped) value,
some a list of possible values and others the combined list of all values.
Depending on which of these functions a particular command/module uses when
reading the configuration, you can potentially see a number of things happen:</p>

<ul>
<li>you might see the local value (from rebar.config) get applied</li>
<li>you might see the value from the parent config get applied (e.g., if there is no local config)</li>
<li>you might see the local value get ignored</li>
</ul>


<p>I strongly recommend spending some time looking at rebar’s config module if
you’re planning on writing plugins (or using complex plugins written by
others), as it’ll save you a lot of head scratching time if you understand this
up front.</p>

<h2>What are plugins?</h2>

<p>As far as rebar is concerned, plugins are simply Erlang modules that it knows
something about. There are essentially two ways that rebar knows about modules:</p>

<ul>
<li>From the rebar.app configuration file</li>
<li>Via the plugins section of the build configuration</li>
</ul>


<p>Modules registered in the rebar.app configuration file are basically part of
rebar itself. Plugins on the other hand, are modules which any given build
configuration (somewhere in the tree) registers via the <code>plugins</code> configuration
element. This configuration is built up to include every level, including the
global config, so if you’ve got no local <code>plugins</code> configuration, this does
not mean <code>plugins</code> won’t get run in your subdirectories. In practise, this
means that plugins registered up top (e.g., globally or in the <code>base_dir</code>
configuration) will get run in all your sub-directories, including of course
dependencies. Bare this in mind when using plugins, and take advantage of
<code>skip_deps</code>, <code>apps=</code> and <code>skip_apps=</code> where necessary to avoid unexpected
things happening in your sub-dirs and deps folders.</p>

<p>When we look at authoring plugins later in the series, we&#8217;ll examine the
various ways in which you can code your plugins to be aware of the scope in
which they&#8217;re executing.</p>

<h2>Plugin Classification</h2>

<p>To (hopefully) make the differences between plugin extensions and built-in
modules a bit clearer, we’re going to classify plugin extensions into three
groups, and will hereafter refer to them simply as plugins:</p>

<ul>
<li>Internal/Built-in</li>
<li>External/Pre-packaged</li>
<li>Local</li>
</ul>


<p>Let’s look at what these classifications mean in practise, and hopefully get an
understanding of the terminology I’ve chosen. Internal (or built-in) modules
come bundled as part of rebar itself, and as per the documentation, these are
registered in the rebar application config file. The functionality exposed by
these modules is available to every rebar user, so they work <em>Out Of The Box</em>.
These plugins are the least likely to be used for extending rebar however,
because in practise they require you to either (a) maintain a custom fork of
rebar or (b) submit a pull request in order for your extension(s) to be
accepted as part of the main source tree. It is the other two types of plugin
we will be looking at in this post.</p>

<h3>External Plugins</h3>

<p>Pre-packaged plugins are bundled as separate Erlang/OTP libraries to be
installed globally, or included in a project using rebar’s dependency handling
mechanism. The latter technique is more useful, as it ensures that someone who
fetches your source code to build/install it, will be able to obtain the right
plugins without going outside of the project source tree.</p>

<p>The key thing to understand here is that the plugin must be installed <em>somehow</em>
in order for rebar to pick it up. We’ve mentioned that rebar knows about
plugins because they’re in the <code>{plugins, ListOfPlugins}</code>
configuration element,  but in practise things aren’t quite that simple. In
order for a plugin to actually get executed (in response to a specific command,
it’s pre/post hooks or indeed the special preprocess and postprocess commands),
it needs to be on the code path! This is fine if the plugin is installed
globally into the user’s erl environment (for example by putting it’s
application root directory somewhere on the ERL_LIBS environment variable), but
not so fine if you’re fetching it into the project’s dependencies. If the
dependency is a direct one, then the <code>preprocess</code> handler in rebar_deps will
nicely update the code path for all commands, so as long as you’re not trying
to make the plugin run before rebar’s built-in modules (which is, in fact,
impossible) then it’ll be on the path. This once again doesn’t always work in
practise, because the function that builds up the code path makes no
attempt to deal with transitive dependencies. I keep meaning to do a pull
request for this, but I’m waiting for others to get through the queue first.</p>

<h3>Local Plugins</h3>

<p>You probably recall that I mentioned plugins need to be on the code path in
order to be executed by rebar? Well thanks to a nifty pull request from yours
truly, there is in fact another way. If rebar cannot find a module on the code
path matching the name given to the plugins configuration element, it will
attempt to locate a source file for the module in either the base_dir or the
directory indicated by the plugin_dir config element. If it finds a source file
with a matching name, it attempts to compile it on the fly and load the beam
code into the running emulator, thereby making the plugin available
dynamically.</p>

<p>The aim of local plugins is to provide a mechanism for scripting complex
tasks/hooks that apply only to your specific project. This is in contrast with
the idea of external/pre-packaged plugins, which provide add-on re-usable
features to rebar that can be used across projects.</p>

<h2>Next time…</h2>

<p>Next time we’ll be looking at the structure of the plugin callback functions
and how to use them in practise. We’ll also be taking a whirlwind tour of some
of the commonly (re)used rebar modules such as rebar_config, rebar_utils and
rebar_log, as well as discussing some of the pros and cons of using plugins and
what the current workarounds look like. We’ll finish with a working example of
an external plugin that adds new functionality to rebar with all the source
code available on github.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Tim Watson</span></span>

      








  


<time datetime="2011-12-29T21:49:00+00:00" pubdate data-updated="true">Dec 29<span>th</span>, 2011</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://hyperthunk.github.com/rebar-plugin-tutorial/blog/2011/12/29/introducing-rebar-plugins/" data-via="" data-counturl="http://hyperthunk.github.com/rebar-plugin-tutorial/blog/2011/12/29/introducing-rebar-plugins/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/rebar-plugin-tutorial/blog/2011/12/29/introducing-rebar-plugins/">Introducing Rebar Plugins</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/hyperthunk">@hyperthunk</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'hyperthunk',
            count: 20,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/rebar-plugin-tutorial/javascripts/github.js" type="text/javascript"> </script>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Tim Watson -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
